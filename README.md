# Diagram Tool

다이어그램 툴 만들기

## 목표

다이어그램을 만들기 위한 기본적인 노드 배치 구현 및 노드 사이의 연결 구현하기

## 기술 스택
* HTML
* CSS
* vanilla javascript

## 구현내용 및 방법

### 노드 생성

Node 메뉴에 위치한 아이템을 클릭하거나 드래그하여 가운데에 위치한 보드에 위치시킴으로써 생성 가능

(아이템을 클릭할 경우 보드의 중앙에 생성됨)

<br>


#### 구현 방법

* 아이템 위치에서 MouseDown의 경우

MouseDown 위치의 ViewPort 좌표를 SVG(보드) 좌표로 변환하여 노드를 생성

<br> 

* document에서 MouseMove의 경우 

해당 노드를 그룹화한 <g>태그의 transform을 변경시켜 이동

<br> 

* 아이템 위치에서 MouseUp의 경우

보드의 중앙 위치를 나타내는 ViewPort 좌표를 SVG 좌표로 변환하여 노드 이동

<br> 

* SVG 태그(보드) 위치에서 MouseUp의 경우

MouseUp 위치의 ViewPort 좌표를 SVG 좌표로 변환 및 이동

<br> 
<br> 

이벤트들을 노드 생성 때마다 부착하는 방법이 아닌 이벤트 위임을 통해 구현하였다.

<hr>
  
### 노드 선택 및 그룹화

  * 클릭을 통한 노드 선택 시 selected 클래스 추가 및 stroke를 변경함으로써 선택항목 시각화
  * Ctrl 키와 함께 노드를 클릭 시 선택된 그룹에 추가

<hr>

### Resizer

  * 선택된 노드의 크기를 바꿀 수 있는 포인터

#### 구현 방법
  
  * 선택된 노드의 transform의 영향을 받지 않기 위해 따로 \<g>태그를 이용하여 그룹화
  * getBBox와 선택된 노드의 transform 값을 가지고 포인터의 위치 계산(SVG 좌표계)
  * DEFAULT_SNAP_GAP보다 작은 부분은 버림 처리하여 스케일 계산

<hr>


### 노드 크기 변경
  
  * Resizer를 드래그함으로써 노드의 크기 변경 가능

#### 구현 방법

  * Resizer 클릭 위치와 드래그한 위치의 ViewPort 좌표를 SVG 좌표로 변환 
  * getBBox를 통한 원본 크기 기준으로 배율 계산
  * 선택 노드의 transform 변경

<hr>
  
 
### 그리드와 스냅

  * \<defs>태그와 \<use>태그를 이용하여 그리드 구현
  * DEFAULT_SNAP_GAP보다 작은 부분은 버림 처리하여 스냅 구현

<hr>

### 노드 사이의 연결

  2개의 노드 사이의 연결을 보여주는 화살표 표시  
  
#### 구현 방법
  
  LeaderLine.JS를 이용하여 구현
  
<hr>

### 그 외의 기능
  * Delete 키를 이용한 선택된 그룹 삭제
  * 마우스 휠을 클릭하여 보드 이동
  * 보드에서 Ctrl 및 마우스 휠을 이용한 ZOOM
  * 노드에 text 입력
  * 글자 크기 변경
  * 왼쪽 메뉴 크기 변경

## 주의사항
* 추가하는 SVG는 빈 공간이 없어야 한다.

ex) 2번째 아이템의 경우 SVG를 만들 때 레이어에 가득 채우지 않아 크기 변경과 같은 동작에서 원치 않는 방향으로 동작한다.
  
  (투명한 공간까지 계산되기 때문)

* ZOOM 및 마우스 휠을 통한 보드 이동의 경우 드래그와 크기 변경은 정상작동하나, 노드 사이의 화살표가 정상작동하지 않는다. 

이는 LeaderLine.JS가 자체 SVG에 그리기 때문으로, 다른 방법을 찾아볼 것이다. (\<line>태그 이용하여 직접 구현하는 방법 등)

## 생각하고 있는 추가 구현
*  \<foreignObject> 태그를 이용하여 \<SVG>태그 내부에 html 태그들을 넣어 \<text>태그와 같은 부분을 대체
*  Ctrl Z 및 Ctrl Y를 통한 히스토리 기능 => \<canvas>와 달리 \<SVG>는 DOM으로 접근이 가능하기 때문에 DomTree를 저장하는 식으로 구현할 수 있을 것이다.
*  코드를 한번 정리를 해보려 한다. (노드를 커스텀 태그와 같이 클래스화 등)
*  드래그를 통한 그룹 선택

## 구현하면서 느낀 점 및 배운 점

* 크게 SVG를 이용한 방식과 Canvas를 이용한 방식으로 구현할 수 있었는데 SVG 방식을 선택한 이유는 크게 두 가지이며 다음과 같다.
  
1. ZOOM을 통해 확대 및 축소 시 깨지지 않는 효과
2. DOM 요소로써 접근이 가능
  
* SVG는 자신만의 좌표계를 가지고 있기 때문에 기능을 구현할 때 좌표계에 대한 신경을 써야 했다.
* 이벤트 처리 방식에 대하여 익숙해질 수 있었다.
* SVG 엘리멘트들을 사용하면서 느낀 불편한 점들은 다음과 같다.
1. rect 태그가 아니면 width와 height를 구하기가 어렵다.
2. 위치가 SVG 좌표계에서 나타나고 \<g>태그는 x y 속성을 제공하지 않기에 transform을 조작하는 방식으로 처리할 수밖에 없었다. 
  따라서 픽셀 단위와 같이 세밀하게 조작하는 데 어려움을 겪었다. 
3. 기본적으로 제공하는 기능이 기본적인 html 태그들에 비해 약하다.
4. Canvas를 활용하는 방법보다 커뮤니티가 작다. => SVG 엘리멘트들의 사용에 익숙하지 않아 시간이 배로 걸렸다.
  
이러한 단점들 때문에 다시 프로젝트를 한다면 Canvas 또는 순수 html 태그들을 이용하여 구현해 볼 것이다.
  
  
* 라이브러리 없이 구현해 보니 자잘한 실수와 고려해야 할 사항들이 너무 많아짐을 느꼈다. 
  따라서 나의 코드를 외부 라이브러리와 같이 리팩토링을 통하여 정리하며 작업해 나가는 것의 중요함을 느꼈다.
  
* 프로젝트를 진행하기 전에 많은 사전 조사가 필요함을 느꼈다. 
  SVG 엘리멘트들은 위치 또는 크기를 조작할 때 순수 html 태그보다 불편함이 있었기 때문이었다. 
  또한 SVG에 대한 질문 및 답변들이 많지 않아 문제를 해결해 나가는 데에 있어서 어려움이 있었기 때문이다.
  해당 프로젝트에 가장 어울리는 도구 및 접근법을 찾는 것의 중요함을 느낄 수 있었다.

  
설명회를 듣고 5일간 맨바닥부터 구현을 해보았는데 기술적인 측면보다도 코드의 일관성, 모듈성과 같은 부분이 더욱 중요함을 느꼈다. 

일관성, 모듈화가 부족하다 보니 쉬운 작업들도 시간이 배로 걸리는 것을 느꼈기 때문이다.

이후 코딩 테스트 준비를 위해 구현은 여기서 일단 멈춰야 할 것 같다.
